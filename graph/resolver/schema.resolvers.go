package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"
	"io"
	"math"
	"strconv"
	"strings"
	"time"

	"github.com/cnpf/feeder-backend/graph/generated"
	"github.com/cnpf/feeder-backend/graph/model"
	"github.com/cnpf/feeder-backend/internal/domain/entity"
	apperrors "github.com/cnpf/feeder-backend/internal/errors"
	"github.com/cnpf/feeder-backend/internal/gemini"
	"github.com/cnpf/feeder-backend/internal/search"
	"github.com/cnpf/feeder-backend/internal/usecase"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.AuthResult, error) {
	// Convert GraphQL upload to UseCase PhotoUpload
	var avatar *usecase.PhotoUpload
	if input.Avatar != nil {
		avatar = &usecase.PhotoUpload{
			File:        input.Avatar.File,
			Size:        input.Avatar.Size,
			ContentType: input.Avatar.ContentType,
		}
	}

	// Call UseCase
	result, err := r.useCase.Register(ctx, input.Email, input.Username, input.Password, input.PasswordConfirm, avatar)
	if err != nil {
		return nil, err
	}

	// Set cookie if token is present
	if result.Token != nil {
		setAuthCookie(ctx, *result.Token)
	}

	return result, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthResult, error) {
	// Call UseCase
	result, err := r.useCase.Login(ctx, input.Login, input.Password)
	if err != nil {
		return nil, err
	}

	// Set cookie if token is present
	if result.Token != nil {
		setAuthCookie(ctx, *result.Token)
	}

	return result, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context) (bool, error) {
	// Call UseCase
	result, err := r.useCase.Logout(ctx)
	if err != nil {
		return false, err
	}

	// Clear cookie
	clearAuthCookie(ctx)

	return result, nil
}

// UpdateProfile is the resolver for the updateProfile field.
func (r *mutationResolver) UpdateProfile(ctx context.Context, input model.UpdateProfileInput) (*model.User, error) {
	// Extract userID from context
	currentUser, err := getCurrentUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, fmt.Errorf("Не авторизован")
	}

	// Convert GraphQL upload to UseCase PhotoUpload
	var avatar io.Reader
	var avatarSize int64
	var avatarContentType string
	if input.Avatar != nil {
		avatar = input.Avatar.File
		avatarSize = input.Avatar.Size
		avatarContentType = input.Avatar.ContentType
	}

	// Call UseCase
	return r.useCase.UpdateProfile(ctx, currentUser.ID, input.Username, input.RemoveAvatar, avatar, avatarSize, avatarContentType)
}

// UpdatePassword is the resolver for the updatePassword field.
func (r *mutationResolver) UpdatePassword(ctx context.Context, oldPassword string, newPassword string) (bool, error) {
	// Extract userID from context
	currentUser, err := getCurrentUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return false, fmt.Errorf("unauthorized")
	}

	// Call UseCase
	return r.useCase.UpdatePassword(ctx, currentUser.ID, oldPassword, newPassword)
}

// CreateReport is the resolver for the createReport field.
func (r *mutationResolver) CreateReport(ctx context.Context, input model.CreateReportInput) (*model.Report, error) {
	user, err := getCurrentUserFromContext(ctx)
	if err != nil || user == nil {
		return nil, fmt.Errorf("Не авторизован")
	}

	// Validate input
	title := strings.TrimSpace(input.Title)
	text := strings.TrimSpace(input.Text)

	if len(title) < 3 || len(title) > 120 {
		return nil, fmt.Errorf("title must be between 3 and 120 characters")
	}
	if len(text) < 1 || len(text) > 5000 {
		return nil, fmt.Errorf("text must be between 1 and 5000 characters")
	}

	// Process photo uploads
	photos := bson.A{}
	if len(input.Photos) > 0 {
		const maxPhotos = 10
		const maxPhotoSize = 2 * 1024 * 1024 // 2MB

		if len(input.Photos) > maxPhotos {
			return nil, fmt.Errorf("too many photos (max %d)", maxPhotos)
		}

		for _, upload := range input.Photos {
			if upload == nil {
				continue
			}

			// Validate file type
			if !strings.HasPrefix(upload.ContentType, "image/") {
				return nil, fmt.Errorf("photo must be an image")
			}

			// Validate file size
			if upload.Size > maxPhotoSize {
				return nil, fmt.Errorf("photo file too large (max 2MB)")
			}

			// Read file data
			data, err := io.ReadAll(upload.File)
			if err != nil {
				return nil, apperrors.WrapError("не удалось прочитать файл фотографии", err)
			}

			photos = append(photos, bson.M{
				"contentType": upload.ContentType,
				"data":        data,
			})
		}
	}

	// Convert photos from bson.A to []interface{}
	photosList := make([]interface{}, len(photos))
	for i, photo := range photos {
		photosList[i] = photo
	}

	// Create entity.Report
	reportEntity := &entity.Report{
		AuthorID:  user.ID,
		Title:     title,
		Text:      text,
		Photos:    photosList,
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}

	reportID, err := r.reportRepo.Create(ctx, reportEntity)
	if err != nil {
		return nil, apperrors.WrapError("не удалось создать отчет", err)
	}

	reportDoc, err := r.reportRepo.FindByID(ctx, reportID)
	if err != nil {
		return nil, apperrors.WrapError("не удалось найти созданный отчет", err)
	}

	return r.formatReportFromEntity(ctx, reportDoc, user)
}

// UpdateReport is the resolver for the updateReport field.
func (r *mutationResolver) UpdateReport(ctx context.Context, id string, input model.UpdateReportInput) (*model.Report, error) {
	user, err := getCurrentUserFromContext(ctx)
	if err != nil || user == nil {
		return nil, fmt.Errorf("Не авторизован")
	}

	if !primitive.IsValidObjectID(id) {
		return nil, fmt.Errorf("Неверный ID")
	}

	// Check if report exists and get author
	authorID, err := r.reportRepo.GetAuthorID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("Отчет не найден")
	}

	if !isAllowed(user, authorID) {
		return nil, fmt.Errorf("Доступ запрещен")
	}

	reportDoc, err := r.reportRepo.FindByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("Отчет не найден")
	}

	// Start with existing report data
	updatedReport := &entity.Report{
		ID:        reportDoc.ID,
		AuthorID:  reportDoc.AuthorID,
		Title:     reportDoc.Title,
		Text:      reportDoc.Text,
		Photos:    reportDoc.Photos,
		CreatedAt: reportDoc.CreatedAt,
		UpdatedAt: time.Now(),
	}

	// Update title if provided
	if input.Title != nil {
		title := strings.TrimSpace(*input.Title)
		if len(title) < 3 || len(title) > 120 {
			return nil, fmt.Errorf("title must be between 3 and 120 characters")
		}
		updatedReport.Title = title
	}

	// Update text if provided
	if input.Text != nil {
		text := strings.TrimSpace(*input.Text)
		if len(text) < 1 || len(text) > 5000 {
			return nil, fmt.Errorf("text must be between 1 and 5000 characters")
		}
		updatedReport.Text = text
	}

	// Handle photo removal
	if input.RemoveAllPhotos != nil && *input.RemoveAllPhotos {
		updatedReport.Photos = []interface{}{}
	} else if len(input.RemovePhoto) > 0 {
		removeIdx := make(map[int]bool)
		for _, idx := range input.RemovePhoto {
			removeIdx[idx] = true
		}
		newPhotos := []interface{}{}
		for i, photo := range updatedReport.Photos {
			if !removeIdx[i] {
				newPhotos = append(newPhotos, photo)
			}
		}
		updatedReport.Photos = newPhotos
	}

	// Handle new photo uploads
	if len(input.Photos) > 0 {
		const maxPhotos = 10
		const maxPhotoSize = 2 * 1024 * 1024 // 2MB

		currentCount := len(updatedReport.Photos)
		if currentCount+len(input.Photos) > maxPhotos {
			return nil, fmt.Errorf("too many photos (max %d)", maxPhotos)
		}

		// Process new uploads
		for _, upload := range input.Photos {
			if upload == nil {
				continue
			}

			// Validate file type
			if !strings.HasPrefix(upload.ContentType, "image/") {
				return nil, fmt.Errorf("photo must be an image")
			}

			// Validate file size
			if upload.Size > maxPhotoSize {
				return nil, fmt.Errorf("photo file too large (max 2MB)")
			}

			// Read file data
			data, err := io.ReadAll(upload.File)
			if err != nil {
				return nil, apperrors.WrapError("не удалось прочитать файл фотографии", err)
			}

			updatedReport.Photos = append(updatedReport.Photos, map[string]interface{}{
				"contentType": upload.ContentType,
				"data":        data,
			})
		}
	}

	err = r.reportRepo.Update(ctx, id, updatedReport)
	if err != nil {
		return nil, apperrors.WrapError("не удалось обновить отчет", err)
	}

	updatedReportDoc, err := r.reportRepo.FindByID(ctx, id)
	if err != nil {
		return nil, apperrors.WrapError("не удалось найти обновленный отчет", err)
	}

	return r.formatReportFromEntity(ctx, updatedReportDoc, user)
}

// DeleteReport is the resolver for the deleteReport field.
func (r *mutationResolver) DeleteReport(ctx context.Context, id string) (bool, error) {
	user, err := getCurrentUserFromContext(ctx)
	if err != nil || user == nil {
		return false, fmt.Errorf("unauthorized")
	}

	if !primitive.IsValidObjectID(id) {
		return false, fmt.Errorf("invalid id")
	}

	// Check if report exists and get author
	authorID, err := r.reportRepo.GetAuthorID(ctx, id)
	if err != nil {
		return false, fmt.Errorf("report not found")
	}

	if !isAllowed(user, authorID) {
		return false, fmt.Errorf("Доступ запрещен")
	}

	err = r.reportRepo.Delete(ctx, id)
	if err != nil {
		return false, apperrors.WrapError("не удалось удалить отчет", err)
	}

	return true, nil
}

// CreateCompetition is the resolver for the createCompetition field.
func (r *mutationResolver) CreateCompetition(ctx context.Context, input model.CompetitionInput) (*model.Competition, error) {
	user, err := getCurrentUserFromContext(ctx)
	if err != nil || user == nil {
		return nil, fmt.Errorf("Не авторизован")
	}
	if !user.IsAdmin {
		return nil, fmt.Errorf("Доступ запрещен")
	}

	if !input.IndividualFormat && !input.TeamFormat {
		return nil, fmt.Errorf("выберите хотя бы один формат соревнований")
	}

	// Parse dates
	startDate, err := time.Parse(time.RFC3339, input.StartDate)
	if err != nil {
		return nil, fmt.Errorf("invalid startDate: %w", err)
	}
	endDate, err := time.Parse(time.RFC3339, input.EndDate)
	if err != nil {
		return nil, fmt.Errorf("invalid endDate: %w", err)
	}

	// Parse tours
	tours := bson.A{}
	for _, tourInput := range input.Tours {
		tourDate, err := time.Parse(time.RFC3339, tourInput.Date)
		if err != nil {
			return nil, fmt.Errorf("invalid tour date: %w", err)
		}
		tours = append(tours, bson.M{
			"date": primitive.NewDateTimeFromTime(tourDate),
			"time": tourInput.Time,
		})
	}

	var fee *float64
	if input.Fee != nil && *input.Fee != "" {
		f, err := strconv.ParseFloat(*input.Fee, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid fee: %w", err)
		}
		fee = &f
	}

	var teamLimit *int32
	if input.TeamLimit != nil && *input.TeamLimit != "" {
		tl, err := strconv.ParseInt(*input.TeamLimit, 10, 32)
		if err != nil {
			return nil, fmt.Errorf("invalid teamLimit: %w", err)
		}
		t := int32(tl)
		teamLimit = &t
	}

	// Convert tours to entity.Tour
	entityTours := make([]entity.Tour, len(input.Tours))
	for i, tourInput := range input.Tours {
		tourDate, err := time.Parse(time.RFC3339, tourInput.Date)
		if err != nil {
			return nil, fmt.Errorf("invalid tour date: %w", err)
		}
		entityTours[i] = entity.Tour{
			Date: tourDate,
			Time: tourInput.Time,
		}
	}

	var openingDateEntity *time.Time
	if input.OpeningDate != nil && *input.OpeningDate != "" {
		od, err := time.Parse(time.RFC3339, *input.OpeningDate)
		if err != nil {
			return nil, fmt.Errorf("invalid openingDate: %w", err)
		}
		openingDateEntity = &od
	}

	var teamLimitInt *int
	if teamLimit != nil {
		t := int(*teamLimit)
		teamLimitInt = &t
	}

	var regulationsStr *string
	if input.Regulations != nil {
		s := strings.TrimSpace(*input.Regulations)
		regulationsStr = &s
	}

	// Create entity.Competition
	competitionEntity := &entity.Competition{
		Title:            strings.TrimSpace(input.Title),
		StartDate:        &startDate,
		EndDate:          &endDate,
		Location:         strings.TrimSpace(input.Location),
		Tours:            entityTours,
		OpeningDate:      openingDateEntity,
		OpeningTime:      input.OpeningTime,
		IndividualFormat: input.IndividualFormat,
		TeamFormat:       input.TeamFormat,
		Fee:              fee,
		TeamLimit:        teamLimitInt,
		Regulations:      regulationsStr,
		CreatedAt:        time.Now(),
		UpdatedAt:        time.Now(),
	}

	competitionID, err := r.competitionRepo.Create(ctx, competitionEntity)
	if err != nil {
		return nil, fmt.Errorf("failed to create competition: %w", err)
	}

	competitionDoc, err := r.competitionRepo.FindByID(ctx, competitionID)
	if err != nil {
		return nil, fmt.Errorf("failed to find created competition: %w", err)
	}

	return formatCompetitionFromEntity(competitionDoc)
}

// UpdateCompetition is the resolver for the updateCompetition field.
func (r *mutationResolver) UpdateCompetition(ctx context.Context, id string, input model.CompetitionInput) (*model.Competition, error) {
	user, err := getCurrentUserFromContext(ctx)
	if err != nil || user == nil {
		return nil, fmt.Errorf("Не авторизован")
	}
	if !user.IsAdmin {
		return nil, fmt.Errorf("Доступ запрещен")
	}

	if !primitive.IsValidObjectID(id) {
		return nil, fmt.Errorf("invalid id")
	}

	if !input.IndividualFormat && !input.TeamFormat {
		return nil, fmt.Errorf("выберите хотя бы один формат соревнований")
	}

	// Check if competition exists
	_, err = r.competitionRepo.FindByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("competition not found")
	}

	// Parse dates
	startDate, err := time.Parse(time.RFC3339, input.StartDate)
	if err != nil {
		return nil, fmt.Errorf("invalid startDate: %w", err)
	}
	endDate, err := time.Parse(time.RFC3339, input.EndDate)
	if err != nil {
		return nil, fmt.Errorf("invalid endDate: %w", err)
	}

	// Get existing competition
	existingCompetition, err := r.competitionRepo.FindByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("competition not found")
	}

	// Convert tours to entity.Tour
	entityTours := make([]entity.Tour, len(input.Tours))
	for i, tourInput := range input.Tours {
		tourDate, err := time.Parse(time.RFC3339, tourInput.Date)
		if err != nil {
			return nil, fmt.Errorf("invalid tour date: %w", err)
		}
		entityTours[i] = entity.Tour{
			Date: tourDate,
			Time: tourInput.Time,
		}
	}

	var openingDateEntity *time.Time
	if input.OpeningDate != nil && *input.OpeningDate != "" {
		od, err := time.Parse(time.RFC3339, *input.OpeningDate)
		if err != nil {
			return nil, fmt.Errorf("invalid openingDate: %w", err)
		}
		openingDateEntity = &od
	}

	var fee *float64
	if input.Fee != nil && *input.Fee != "" {
		f, err := strconv.ParseFloat(*input.Fee, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid fee: %w", err)
		}
		fee = &f
	}

	var teamLimitInt *int
	if input.TeamLimit != nil && *input.TeamLimit != "" {
		tl, err := strconv.ParseInt(*input.TeamLimit, 10, 32)
		if err != nil {
			return nil, fmt.Errorf("invalid teamLimit: %w", err)
		}
		t := int(tl)
		teamLimitInt = &t
	}

	var regulationsStr *string
	if input.Regulations != nil {
		s := strings.TrimSpace(*input.Regulations)
		regulationsStr = &s
	}

	// Update entity.Competition
	updatedCompetition := &entity.Competition{
		ID:               existingCompetition.ID,
		Title:            strings.TrimSpace(input.Title),
		StartDate:        &startDate,
		EndDate:          &endDate,
		Location:         strings.TrimSpace(input.Location),
		Tours:            entityTours,
		OpeningDate:      openingDateEntity,
		OpeningTime:      input.OpeningTime,
		IndividualFormat: input.IndividualFormat,
		TeamFormat:       input.TeamFormat,
		Fee:              fee,
		TeamLimit:        teamLimitInt,
		Regulations:      regulationsStr,
		CreatedAt:        existingCompetition.CreatedAt,
		UpdatedAt:        time.Now(),
	}

	err = r.competitionRepo.Update(ctx, id, updatedCompetition)
	if err != nil {
		return nil, fmt.Errorf("failed to update competition: %w", err)
	}

	competitionDoc, err := r.competitionRepo.FindByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to find updated competition: %w", err)
	}

	return formatCompetitionFromEntity(competitionDoc)
}

// DeleteCompetition is the resolver for the deleteCompetition field.
func (r *mutationResolver) DeleteCompetition(ctx context.Context, id string) (bool, error) {
	user, err := getCurrentUserFromContext(ctx)
	if err != nil || user == nil {
		return false, fmt.Errorf("unauthorized")
	}
	if !user.IsAdmin {
		return false, fmt.Errorf("Доступ запрещен")
	}

	if !primitive.IsValidObjectID(id) {
		return false, fmt.Errorf("invalid id")
	}

	err = r.competitionRepo.Delete(ctx, id)
	if err != nil {
		return false, fmt.Errorf("failed to delete competition: %w", err)
	}

	return true, nil
}

// AdminUpdateUser is the resolver for the adminUpdateUser field.
func (r *mutationResolver) AdminUpdateUser(ctx context.Context, id string, isAdmin *bool) (*model.User, error) {
	user, err := getCurrentUserFromContext(ctx)
	if err != nil || user == nil {
		return nil, fmt.Errorf("Не авторизован")
	}
	if !user.IsAdmin {
		return nil, fmt.Errorf("Доступ запрещен")
	}

	if !primitive.IsValidObjectID(id) {
		return nil, fmt.Errorf("invalid user id")
	}

	// Don't allow removing admin rights from the last admin
	if isAdmin != nil && !*isAdmin {
		adminsCount, err := r.userRepo.CountAdmins(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to count admins: %w", err)
		}
		if adminsCount <= 1 {
			targetUser, err := r.userRepo.FindByID(ctx, id)
			if err == nil && targetUser.IsAdmin {
				return nil, fmt.Errorf("нельзя убрать права у последнего админа")
			}
		}
	}

	// Get existing user
	existingUser, err := r.userRepo.FindByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("user not found")
	}

	// Update only isAdmin field
	updatedUser := &entity.User{
		ID:           existingUser.ID,
		Email:        existingUser.Email,
		Username:     existingUser.Username,
		PasswordHash: existingUser.PasswordHash,
		IsAdmin:      existingUser.IsAdmin,
		HasAvatar:    existingUser.HasAvatar,
		Avatar:       existingUser.Avatar,
		CreatedAt:    existingUser.CreatedAt,
	}

	if isAdmin != nil {
		updatedUser.IsAdmin = *isAdmin
	} else {
		return nil, fmt.Errorf("Нет полей для обновления")
	}

	err = r.userRepo.Update(ctx, id, updatedUser)
	if err != nil {
		return nil, fmt.Errorf("failed to update user: %w", err)
	}

	// Fetch updated user
	finalUser, err := r.userRepo.FindByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("user not found: %w", err)
	}

	return formatUserFromEntity(finalUser), nil
}

// AdminDeleteUser is the resolver for the adminDeleteUser field.
func (r *mutationResolver) AdminDeleteUser(ctx context.Context, id string) (bool, error) {
	user, err := getCurrentUserFromContext(ctx)
	if err != nil || user == nil {
		return false, fmt.Errorf("unauthorized")
	}
	if !user.IsAdmin {
		return false, fmt.Errorf("Доступ запрещен")
	}

	if !primitive.IsValidObjectID(id) {
		return false, fmt.Errorf("invalid user id")
	}

	// Don't allow deleting yourself
	if user.ID == id {
		return false, fmt.Errorf("cannot delete yourself")
	}

	err = r.userRepo.Delete(ctx, id)
	if err != nil {
		return false, fmt.Errorf("failed to delete user: %w", err)
	}

	return true, nil
}

// CreateRegistration is the resolver for the createRegistration field.
func (r *mutationResolver) CreateRegistration(ctx context.Context, input model.CreateRegistrationInput) (*model.Registration, error) {
	user, err := getCurrentUserFromContext(ctx)
	if err != nil || user == nil {
		return nil, fmt.Errorf("Не авторизован")
	}

	// Convert GraphQL input to UseCase input
	participants := make([]usecase.ParticipantInput, len(input.Participants))
	for i, p := range input.Participants {
		participants[i] = usecase.ParticipantInput{
			FirstName: p.FirstName,
			LastName:  p.LastName,
		}
	}

	var coach *usecase.CoachInput
	if input.Coach != nil {
		coach = &usecase.CoachInput{
			FirstName: input.Coach.FirstName,
			LastName:  input.Coach.LastName,
		}
	}

	return r.useCase.CreateRegistration(ctx, user.ID, input.CompetitionID, input.Type, input.TeamName, participants, coach)
}

// UpdateRegistration is the resolver for the updateRegistration field.
func (r *mutationResolver) UpdateRegistration(ctx context.Context, id string, input model.UpdateRegistrationInput) (*model.Registration, error) {
	user, err := getCurrentUserFromContext(ctx)
	if err != nil || user == nil {
		return nil, fmt.Errorf("Не авторизован")
	}

	// Convert GraphQL input to UseCase input
	participants := make([]usecase.ParticipantInput, len(input.Participants))
	for i, p := range input.Participants {
		participants[i] = usecase.ParticipantInput{
			FirstName: p.FirstName,
			LastName:  p.LastName,
		}
	}

	var coach *usecase.CoachInput
	if input.Coach != nil {
		coach = &usecase.CoachInput{
			FirstName: input.Coach.FirstName,
			LastName:  input.Coach.LastName,
		}
	}

	return r.useCase.UpdateRegistration(ctx, user.ID, id, input.TeamName, participants, coach)
}

// DeleteRegistration is the resolver for the deleteRegistration field.
func (r *mutationResolver) DeleteRegistration(ctx context.Context, id string) (bool, error) {
	user, err := getCurrentUserFromContext(ctx)
	if err != nil || user == nil {
		return false, fmt.Errorf("Не авторизован")
	}

	return r.useCase.DeleteRegistration(ctx, user.ID, id)
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	// Extract userID from context
	currentUser, err := getCurrentUserFromContext(ctx)
	if err != nil || currentUser == nil {
		return nil, nil
	}

	// Call UseCase
	return r.useCase.GetCurrentUser(ctx, currentUser.ID)
}

// Reports is the resolver for the reports field.
func (r *queryResolver) Reports(ctx context.Context, limit *int) ([]*model.Report, error) {
	currentUser, err := getCurrentUserFromContext(ctx)
	if err != nil {
		currentUser = nil
	}

	reportLimit := 20
	if limit != nil {
		reportLimit = int(math.Max(1, math.Min(30, float64(*limit))))
	}

	reportDocs, err := r.reportRepo.FindAll(ctx, reportLimit)
	if err != nil {
		return nil, fmt.Errorf("failed to query reports: %w", err)
	}

	var results []*model.Report
	for _, reportDoc := range reportDocs {
		report, err := r.formatReportFromEntity(ctx, reportDoc, currentUser)
		if err != nil {
			continue
		}
		results = append(results, report)
	}

	return results, nil
}

// Report is the resolver for the report field.
func (r *queryResolver) Report(ctx context.Context, id string) (*model.Report, error) {
	if !primitive.IsValidObjectID(id) {
		return nil, fmt.Errorf("invalid id")
	}

	currentUser, authErr := getCurrentUserFromContext(ctx)
	if authErr != nil {
		currentUser = nil
	}
	reportDoc, err := r.reportRepo.FindByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("report not found")
	}

	return r.formatReportFromEntity(ctx, reportDoc, currentUser)
}

// Competitions is the resolver for the competitions field.
func (r *queryResolver) Competitions(ctx context.Context) ([]*model.Competition, error) {
	competitionDocs, err := r.competitionRepo.FindAll(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to query competitions: %w", err)
	}

	var results []*model.Competition
	for _, competitionDoc := range competitionDocs {
		competition, err := formatCompetitionFromEntity(competitionDoc)
		if err != nil {
			continue
		}
		results = append(results, competition)
	}

	return results, nil
}

// Competition is the resolver for the competition field.
func (r *queryResolver) Competition(ctx context.Context, id string) (*model.Competition, error) {
	if !primitive.IsValidObjectID(id) {
		return nil, fmt.Errorf("invalid id")
	}

	competitionDoc, err := r.competitionRepo.FindByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("competition not found")
	}

	return formatCompetitionFromEntity(competitionDoc)
}

// AdminUsers is the resolver for the adminUsers field.
func (r *queryResolver) AdminUsers(ctx context.Context) ([]*model.User, error) {
	user, err := getCurrentUserFromContext(ctx)
	if err != nil || user == nil {
		return nil, fmt.Errorf("Не авторизован")
	}
	if !user.IsAdmin {
		return nil, fmt.Errorf("Доступ запрещен")
	}

	userDocs, err := r.userRepo.FindAll(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to query users: %w", err)
	}

	var results []*model.User
	for _, userDoc := range userDocs {
		results = append(results, formatUserFromEntity(userDoc))
	}

	return results, nil
}

// AdminUser is the resolver for the adminUser field.
func (r *queryResolver) AdminUser(ctx context.Context, id string) (*model.User, error) {
	user, err := getCurrentUserFromContext(ctx)
	if err != nil || user == nil {
		return nil, fmt.Errorf("Не авторизован")
	}
	if !user.IsAdmin {
		return nil, fmt.Errorf("Доступ запрещен")
	}

	if !primitive.IsValidObjectID(id) {
		return nil, fmt.Errorf("invalid user id")
	}

	userDoc, err := r.userRepo.FindByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("user not found")
	}

	return formatUserFromEntity(userDoc), nil
}

// Chat is the resolver for the chat field.
func (r *queryResolver) Chat(ctx context.Context, query string) (*model.ChatResponse, error) {
	if r.geminiClient == nil {
		return nil, fmt.Errorf("Gemini API не настроен. Добавьте GOOGLE_GEMINI_API_KEY в переменные окружения")
	}

	// Use AI to extract and optimize search query
	optimizedQuery, err := r.geminiClient.ExtractSearchQuery(query)
	if err != nil {
		// Fallback to original query if AI extraction fails
		optimizedQuery = query
	}
	// Log for debugging (can be removed in production)
	if optimizedQuery == "" || optimizedQuery == query {
		// If AI didn't optimize, try fallback with translation
		// This ensures we still search even if AI fails
	}

	// Search for reports and competitions using optimized query
	searchResults, err := search.SearchAll(ctx, r.db, optimizedQuery)
	if err != nil {
		return nil, fmt.Errorf("ошибка при поиске: %w", err)
	}

	if len(searchResults) == 0 {
		return &model.ChatResponse{
			Message: "К сожалению, я не нашел информацию по вашему запросу. Попробуйте переформулировать вопрос.",
			Results: []*model.ChatResult{},
		}, nil
	}

	// Generate AI response using search results directly
	geminiResults := make([]gemini.SearchResult, len(searchResults))
	for i, sr := range searchResults {
		geminiResults[i] = gemini.SearchResult{
			Type:        sr.Type,
			Title:       sr.Title,
			Text:        sr.Text,
			Location:    sr.Location,
			HasPhotos:   sr.HasPhotos,
			PhotosCount: sr.PhotosCount,
		}
	}

	// Generate AI response
	aiMessage, err := r.geminiClient.GenerateChatResponse(query, geminiResults)
	if err != nil {
		// Fallback response if Gemini fails
		if len(searchResults) > 0 {
			first := searchResults[0]
			var itemType string
			if first.Type == "competition" {
				itemType = "соревнование"
			} else {
				itemType = "отчет"
			}
			aiMessage = fmt.Sprintf("Я нашел %d материал(ов) по вашему запросу: \"%s\". Хотите перейти к %s и посмотреть фото?", len(searchResults), first.Title, itemType)
		} else {
			aiMessage = "К сожалению, произошла ошибка при обработке запроса."
		}
	}

	// Convert to GraphQL model
	results := make([]*model.ChatResult, len(searchResults))
	for i, sr := range searchResults {
		location := ""
		if sr.Location != "" {
			location = sr.Location
		}
		results[i] = &model.ChatResult{
			ID:          sr.ID,
			Type:        sr.Type,
			Title:       sr.Title,
			HasPhotos:   sr.HasPhotos,
			PhotosCount: sr.PhotosCount,
			Location:    &location,
		}
	}

	return &model.ChatResponse{
		Message: aiMessage,
		Results: results,
	}, nil
}

// Registrations is the resolver for the registrations field.
func (r *queryResolver) Registrations(ctx context.Context, competitionID string) ([]*model.Registration, error) {
	currentUser, err := getCurrentUserFromContext(ctx)
	if err != nil {
		currentUser = nil
	}
	currentUserID := ""
	if currentUser != nil {
		currentUserID = currentUser.ID
	}

	return r.useCase.GetRegistrationsByCompetition(ctx, competitionID, currentUserID)
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
